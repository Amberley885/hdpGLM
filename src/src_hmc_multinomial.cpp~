// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>

using namespace Rcpp;
using namespace arma;




// to be completed 




mat get_Sigma_multi(List fix)
{
  NumericMatrix Sigma_R = as<NumericMatrix>(fix["Sigma"]);
  mat Sigma(Sigma_R.begin(), Sigma_R.nrow(), Sigma_R.ncol(), false);
  return(Sigma);
}
colvec get_mu_theta_multi(List fix)
{
  NumericVector mu_theta_R = as<NumericVector>(fix["mu.theta"]);
  vec mu_theta(mu_theta_R.begin(), mu_theta_R.length(), false);
  return(mu_theta);
}
double U_multi(colvec theta, List fix)
{
  mat Sigma = get_Sigma_multi(fix);
  vec mu_theta = get_mu_theta_multi(fix);
  return( as_scalar( -   (-1.0/2.0)*( log(2.0*3.141593) + log(det(Sigma)) + (theta - mu_theta).t() * Sigma.i() * (theta - mu_theta) )    ) );
} 
colvec grad_U_multi(colvec theta, List fix)
{
  mat Sigma = get_Sigma_multi(fix);
  vec mu_theta = get_mu_theta_multi(fix);
  mat grad = (theta - mu_theta).t() * Sigma.i();
  return ( grad.t() ) ;
}
mat G_multi(colvec theta)
{
  int D = theta.n_rows;
  vec diag(D);
  diag.fill(1.0);
  mat I = diagmat(diag);
  return(I);
}
// sampling from multivariate normal (http://gallery.rcpp.org/articles/simulate-multivariate-normal/)
colvec q_multi(colvec theta_t, List fix)
{
  mat Sigma = get_Sigma_multi(fix);
  vec mu_theta = get_mu_theta_multi(fix);
  int ncols = Sigma.n_cols;
  arma::mat Y = arma::randn(1, ncols);
  mat sample = arma::repmat(mu_theta, 1, 1).t() + Y * arma::chol(G_multi(theta_t));
  return (sample.row(0).t());
}
