
## {{{ docs }}}

#' Classify data points
#'
#' This function returns a data frame with the data points classified according to the estimation of cluster probabilities generated by the output of the function \code{\link{hdpGLM}}
#'
#'
#' @param data a data frame with the data set used to estimate the \code{\link{hdpGLM}} model
#' @param samples the output of \code{\link{hdpGLM}} 
#'
#' @export

## }}}
hdpGLM_classify <- function(data, samples)
{
    cluster = apply(samples$pik, 1, which.max)
    return(data.frame(Cluster = cluster, data))
}
hdpGLM_match_clusters_aux <- function(estimate, true){
    return(
        true %>%
        dplyr::group_by(k) %>%
        dplyr::full_join(., estimate , by=c("Parameter"))  %>%
        dplyr::mutate(d = edist(True, Mean)) %>%
        dplyr::ungroup(.)  %>%
        dplyr::filter(d == min(d))  %>% 
        dplyr::select(k) %>%
        base::unique(.) %>%
        dplyr::pull(.)
        )
}


## {{{ dpGLM }}}

## {{{ docs }}}

#' Defaul plot for class dpGLM
#'
#' This function generate desity plots with the posterior distribution generated by the function \code{\link{hdpGLM}}
#'
#' @param x a dpGLM object with the samples from generated by \code{\link{hdpGLM}}
#' @param K either \code{NULL} or an integer indicating the number of estimated clusters to plot
#' @param separate boolean, if \code{TRUE} the coefficients of the \code{K} first clusters will be displayed in a separate panel in the plot. If \code{FALSE}, only the beta coefficient will be displayed in a separate panel in the plot
#' @param hpd boolean, if \code{TRUE} the and \code{separate=T}, the .95 HPD lines will be displayed.
#' @param true_parameters either \code{NULL} or a list with the true parameter values if they are known. The list must be as described for the parameter \code{parameters} of the function \code{\link{hdpGLM_simulateData}}
#' @param plot.hist boolean, if \code{TRUE} the histogram is shown together with the densities of the parameters
#' @param plot.cluster.classfication boolean, if \code{TRUE} it generates a bar plot that shows the clusters and the percentage of the data points classified in that cluster
#' @param only.occupied.clusters boolean, if \code{TRUE} it shows the only the densities of the clusters that actually have data points assigned to it with high probability
#' @param layout either \code{NULL} or a two-dimensional vector with integers indicating the number of rows and coluns to plot. If \code{NULL}, the grid is provided
#' @param title  string, the title of the plot
#' @param include.legend boolean, if \code{TRUE} a legend is displayed in the plot identifying the clusters. Used only if \code{separate=FALSE}.
#' @param yaxis boolean, indicates if show y axis in the plot or not 
#' # @param prop.time.active a number between 0 and 1. When \code{separate=F} and \code{plot.cluster.freq=T}, it will count the number of cluster that was active in the provided proportion of the time
#' # @param select_perc_time_active a number between 0 and 100 indicating the cluster to be displayed according to the percentage of the time it was active during the MCMC estimation
#' # @param omit.irrelevant.clusters boolean, if \code{TRUE} it will omit the irrelevant clusters, that is, those cluster whose vector of linear coefficients are not indistinguishable from the zero vector (default is \code{TRUE})
#' @inheritParams graphics::par
#' @inheritParams stats::density
#'
#' @return 
#'
#' @examples
#' dt    = hdpGLM_simulateData(n=5000,nCov=4, K=5, family='gaussian')
#' mcmc    = list(burn.in = 0,  n.iter = 2000)
#' samples = hdpGLM(y~., data=dt$data, mcmc=mcmc,
#'                  family='gaussian', n.display=30, K=100)
#'
#' plot(samples, true_parameters=data$parameters)
#' 
#' \dontrun{
#' }
#' @export
## }}}
plot.dpGLM    <- function(x, K=NULL, separate=FALSE, hpd=TRUE, true_parameters=NULL, plot.hist=TRUE, plot.cluster.classification=TRUE, layout=NULL, title=NULL, prop.time.active=.95, adjust=NULL, only.occupied.clusters=TRUE, include.legend=TRUE, yaxis=T, ...)
{
    par.default <- graphics::par(no.readonly = TRUE)
    on.exit(graphics::par(par.default), add=TRUE)
    op.default <- options()
    on.exit(options(op.default), add=TRUE)
    dir.default <- getwd()
    on.exit(setwd(dir.default), add=TRUE)

    k.dist = x$samples[,'k']
    n.mcmc = attr(x$samples,'mcpar')[2]

    ## return only the clusters whose vetor beta has at least one component for which 0 is not in the HPD
    ## if(omit.irrelevant.clusters) x = dpGLM_select_non_zero(x, select.perc.time.active)
    if(only.occupied.clusters)   x = dpGLM_get_occupied_clusters(x)

    if(is.null(K) & separate)
    {
        K = min(10,length(unique(x$samples[,'k'])) )
    }
    if(is.null(K)) K = length(unique(x$samples[,'k']))

    sample = as.data.frame(x$samples)

    if(!is.null(title) &  yaxis){graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=1.2, mar=c(3,3,5,1), mgp = c(2,.6,0))} 
    if(!is.null(title) & !yaxis){graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=1.2, mar=c(3,1.5,5,1), mgp = c(2,.6,0))} 
    if( is.null(title) &  yaxis){graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=1.2, mar=c(3,3,2,1), mgp = c(2,.6,0))} 
    if( is.null(title) & !yaxis){graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=1.2, mar=c(3,1.5,2,1), mgp = c(2,.6,0))} 
    if(!yaxis){
        ylab=''
        yaxt='n'
        
    }else{
        ylab="Density"
        yaxt='l'
    }

    ## plotting betas
    ## --------------
    Z     = sample %>% dplyr::select(k)  %>% c %>% unlist 
    high.freq.cluster = table(Z) %>% sort  %>% rev  %>% names  %>% as.numeric %>% .[1:K]
    betas = sample %>% dplyr::select(dplyr::contains('beta'))

    if (separate)
    {
        if(is.null(adjust)) adjust = .8
        if(K>10) stop("\nToo many clusters to plot. K must be between 1 and 10.\n\n")
        if(is.null(layout)) graphics::par(mfrow=c(K,ncol(betas)))

        for (k in high.freq.cluster )
        {
            beta = betas[Z==k,]
            for (d in 1:ncol(beta))
            {
                betad = beta[,d]
                hpd999 = coda::HPDinterval(coda::as.mcmc(betad), prob=.97)
                hpd95  = coda::HPDinterval(coda::as.mcmc(betad), prob=.95)
                betad = betad[hpd999[1] <= betad & betad <= hpd999[2] ]
                if(plot.hist){col="lightsteelblue1"}else{col="white"}
                graphics::hist(betad, col=col, border='white', breaks=30, main=bquote(beta[.(k)~.(d)]), probability=T, xlab='',xlim=hpd999, yaxt=yaxt, ylab=ylab)
                graphics::lines(stats::density(betad, adjust=adjust), col='grey')
                if (!is.null(true_parameters))
                {
                    graphics::abline(v=unlist(lapply(true_parameters$beta,'[',d)), col='black', lty=2)
                    ## graphics::legend('topright', legend=bquote('True'~beta[~'k=1:'~.(K)~","~.(d)]),lty=2, bty='n', cex=.8)
                    graphics::legend('topright', legend=bquote('True'),lty=2, bty='n', cex=.8)
                }
                if(hpd)
                {
                    graphics::abline(v=hpd95, col='red', lty=3)
                    graphics::legend('bottomright', legend='95% HPD', bty='n', lty=3, col='red')
                }
            }
        }
    }else
    {
        if(is.null(adjust)) adjust = .3
        if(is.null(layout)) layout = .get_layout(ncol(betas)+1)
        graphics::par(mfrow=layout)

        ## Bar plot with data clustering
        if(plot.cluster.classification){
            k.classification = sort(100*table(apply(x$pik, 1, which.max))/dim(x$pik)[1], decreasing=T)
            bp = graphics::barplot(k.classification, horiz=T, xlab='Percentage of the data classified in the cluster',
                                   ylab='Cluster Label', col="lightsteelblue1", border='white', xlim=c(0,110))
            text(x=k.classification, y=bp, labels=paste0(round(k.classification,2), " %", sep=''), pos=4, xpd=NA)

            ## summary about k during the estimation
            k.summary.distr = table(k.dist)/n.mcmc
            t1=paste0("Data classified in ", length(k.classification)," clusters", "\n",
                      "(Maximum Number of clusters activated: ", length(k.summary.distr), ")",sep='')
            graphics::title(main=t1, cex.main=.8)
            ## graphics::legend('topright', legend=c(t1), bty='n')
            ## t2=paste0("Number of clusters more than ",round(100*prop.time.active,0),"% of the time active: ", sum(k.summary.distr>=prop.time.active),  sep='')
            ## graphics::legend('topright', legend=c(t1,t2), bty='n')

        }

        ## cols=ifelse(K>1, grDevices::palette(grDevices::rainbow(K)), 'black')
        cols='brown1'
        beta = betas[Z %in% high.freq.cluster,]
        for (d in 1:ncol(beta))
        {
            betad = beta[,d]
            hpd999 = coda::HPDinterval(coda::as.mcmc(betad), prob=.999)
            betad = betad[hpd999[1] <= betad & betad <= hpd999[2] ]

            if(plot.hist){col="lightsteelblue1"}else{col="white"}
            graphics::hist(betad, col=col, border='white', breaks=70, main=bquote(beta[.(d)]), probability=T, xlab='', yaxt=yaxt, ylab=ylab)
            graphics::lines(stats::density(betad, adjust=adjust), col='grey20')
            true = sapply(true_parameters$beta, function(x) x[d])
            graphics::abline(v=true, col=cols, lty=2)
            if(!is.null(true_parameters) & include.legend) graphics::legend('topright', legend=paste0('True in Cluster ',1:K, sep=''), col=cols, lty=1:K, bty='n', cex=.9)
        }
    }
    if (!is.null(title)){graphics::title(title,  outer=T, line=-1.5, cex=.8)}
}

## {{{ docs }}}
#' Default Summary function for dpGLM class
#'
#' This function provides a summary of the MCMC samples from the dpGLM model
#'
#' @param x a MCMC object \code{\link{coda}} returned by the \code{\link{dpGLM}} function
#' @param nK either \code{NULL} or an integer representing the number of clusters to display the summary statistics. The clusters displayed are ordered by the proportion of time they were active during the MCMC simulation. If \code{NULL}, the function displays only the clusters that contains data points (see Details)
#' @param HPD.prob a number between 0 and 1 (default is .95). It is used to display the HPD of the posterior distribution
#' @inheritParams plot.dpGLM
#'
#' @details Data points are assigned to clusters according to the highest estimated probability of belonging to that cluster
#' 
#' @export
## }}}
summary.dpGLM <- function(x, nK = NULL, HPD.prob=.95, burn.in=NULL, only.occupied.clusters=TRUE)
{

    if(only.occupied.clusters)   x = dpGLM_get_occupied_clusters(x)

    if (is.null(nK)){
        K = unique(x$samples[,'k'])
    }else{
        K = as.numeric(names(sort(table(x$samples[,'k']), decreasing=T))[1:floor(min(nK, length(unique(x$samples[,'k'])) ) )])
    }

    if (!is.null(burn.in))
    {
        x$samples = coda::as.mcmc(x$samples[burn.in:nrow(x$samples),])
        attr(x$samples, 'mcpar')[2]  = attr(x$samples, 'mcpar')[2] - burn.in
    }
    
    n.mcmc.sample = attr(x$samples, 'mcpar')[2]
    summ = matrix(nrow=0 , ncol=8)

    stopifnot(inherits(x, "dpGLM"))
    for (k in K){
        idx.cluster = x$samples[,'k'] == k
        xk = coda::as.mcmc(x$samples[ idx.cluster, ])
        xk = x$samples[ idx.cluster, -1]
        if (is.null(nrow(xk))){
            ## it is done b/c if there is 1 row, xk is treated as vector by R, and summary and coda::HPDinterval is incorrectly computed
            xk=rbind(xk,xk)
            n.active = round(100*1/n.mcmc.sample,1)
            xk=coda::as.mcmc(xk)
        }else{
            n.active = round(100*nrow(xk)/n.mcmc.sample,1)
            xk=coda::as.mcmc(xk)
        }
        summ = rbind(summ, cbind(k, summary(xk)[[1]], coda::HPDinterval(xk, HPD.prob), n.active))
    }
    summ = summ[order(summ[,'n.active'], decreasing=T),]
    summ           = summ[,c('k',       'Mean','lower','upper','SD','Naive SE', 'Time-series SE')]
    colnames(summ) =         c('Cluster', 'Mean','HPD.l','HPD.u','SD','Naive SE', 'Time-series SE')

    return(summ)
}

## {{{ docs }}}
#' Plot simulated data from hdpGLM model
#'
#' This is a generic function applied to the class \code{dpGLM_data}, which is a list with a data set generated by the function \code{\link{hdpGLM_simulateData}}. It creates a plot describing the data set generated by that function.
#'
#' @param x a dpGLM_data object, generated by the funciton  \code{\link{hdpGLM_simulateData}}
#' @param title  string, the title of the plot
#'
#' @examples
#'
#' \dontrun{
#' }
#' @export
## }}}
plot.dpGLM_data    <- function(sim_data, title=NULL, ...)
{
    if(all(sim_data$data$y==0 | sim_data$data$y==1)) sim_data$data$y = as.factor(sim_data$data$y)
    .dpGLM_densities(sim_data$data)
    graphics::title(title, outer=T, line=-1, cex.main=.9)
}

## {{{ docs }}}

#' Get occupied Clusters
#'
#' This function selects the clusters from the samples of the posterior distribution generated by the function \code{\link{hdpGLM}} that have data classified as belonging to them. See details.
#'
#'
#' @param x an \code{\link{dpGLM}} or \code{\link{hdpGLM}} object generated by the function \code{\link{hdpGLM}} 
#'
#' @return The function returns the same object received, but it selects the occupoed clusters.
#'
#' @details The function \code{\link{hdpGLM}} generates samples from the posterior distribution of the hdpGLM model. That function also estimate the probability that a data point in the data set belongs to a specific cluster. If we classify the data points and assign them to the cluster they have the highest probability to belong to, it will give the clusters that are occupied with data points. This function selects such clusters from the posterior distribution and returns the sample from the posterior only with them.
#'
#' \dontrun{
#' }
#' @export

## }}}
dpGLM_get_occupied_clusters <- function(x)
{
    active = unique(apply(x$pik, 1, which.max))
    idx_active = x$samples[,'k'] %in% active
    n.iter = attr(x$samples, 'mcpar')[2]
    x$samples = coda::as.mcmc(x$samples[idx_active,])
    attr(x$samples, 'mcpar')[2] = n.iter
    return(x)
}

#' @export
print.dpGLM <- function(x,...)
{
    cat(paste0("\nMaximum number of clusters activated during the estimation: ", x$max_active, sep=''))
    cat(paste0("\nNumer of MCMC iterations: ", x$n.iter, sep=''))
    cat(paste0("\nburn-in: ", x$burn.in, "\n", sep=''))
    cat("\nSummary statistics of cluster with data points\n")
    s = summary(x)
    s = s[,-ncol(s)]
    print(s)
    invisible()
}


#' @export
predict.dpGLM <- function(samples, new_data, covar.par.names, family='gaussian', ...)
{
    new_data$Intercept = 1
    if(class(samples)!='dpGLM') stop("\n\nParameter samples must be a dpGLM or hdpGLM object ! \n\n")
    if(!all(names(covar.par.names) %in% names(new_data))) stop("\n\nCheck the value of \'covar.par.names\'\n\n")
    est       = samples %>% summary(.) %>% data.frame(Parameter=rownames(.), ., row.names=1:nrow(.) )  %>%
        filter(Parameter != 'sigma') %>%
        mutate_if(is.factor, as.character) %>% 
        full_join(., covar.par.names  %>% data.frame(covars=names(.),Parameter=., row.names=1:length(.), stringsAsFactors=F), by="Parameter") %>%
        mutate(covars = ifelse(is.na(covars), 'Intercept', covars))
    clusters  = est$Cluster %>% unique
    pred = data_frame()
    for (cluster in clusters)
    {
        est_cl = est %>%
            filter(Cluster == cluster)
        X = new_data %>% select(est_cl$covars) %>%
            as.matrix
        betas = est_cl %>%
            select(Mean, contains("HPD")) %>%
            as.matrix
        if (family=="gaussian") {
            pred.tmp = X %*% betas
        }
        if (family=="binomial") {
            pred.tmp = 1/(1+exp(- X %*% betas))
        }
        pred.tmp = data.frame(pred.tmp, Cluster=cluster)
        pred = pred %>% rbind(., pred.tmp)
    }
    new_data = new_data[rep(1:nrow(new_data), length(clusters)),]
    pred = as_data_frame(pred)  %>%
        bind_cols(new_data) %>%
        rename(pred.mean=Mean, pred.l=HPD.l, pred.u=HPD.u)
    return(pred)
}


dpGLM_plotDensity  <- function(x, ub=stats::quantile(x,.975), lb=stats::quantile(x,.025), shaded.area=F, shaded.area.col='grey90', lty=1, bty='n', add=F, grid=T, ...)
{
    data.rug = sample(x, size=min(1000, length(x)))
    if (add) {
        graphics::lines(stats::density(x, adjust=1), lty=lty,  cex.axis=.9, ...)
    }else{
        graphics::plot(stats::density(x, adjust=1), lty=lty,  cex.axis=.9, ...)
    }
    graphics::rug(x=data.rug)
    if(shaded.area){
    ## shadded area
        ## x.new <- density(x, adjust=1)$x
        x.new<- stats::density(x, adjust=1)$x
        y <- stats::density(x, adjust=1)$y
        x.coord <- c(lb, x.new[lb <= x.new & x.new <= ub], ub)
        y.coord <- c(0,  y[lb <= x.new & x.new <= ub], 0)
        graphics::polygon(x.coord,y.coord,col=shaded.area.col, lty=lty, border= NA)
        length(x.coord)
        length(y.coord)
    }
    if(grid) grid()
}
.dpGLM_barPlot     <- function(y, title='', show.group.name=T, show.group.count=T, col='lightgrey')
{
    if(class(y)=='table') {
        n <- sum(table)
        NAs <- 0
        table <- y
        tableProp <- round(y/sum(y),3)
    }else{
        y <- factor(y)
        n <- length(y)
        NAs <- sum(is.na(y))
        table <- table(y)
        tableProp <- round(table(y)/length(y),3)
        
    }
    if (show.group.count){
        N <- paste('\n(N=',table,')', sep='')
        names(tableProp) <-  paste(names(table),N)
    }        
    ypos <- graphics::barplot(tableProp, horiz=T, xlim=c(0,1.1), main=title,plot=F)
    graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=.9, mar=c(4,5,3,0))
    graphics::barplot(tableProp, horiz=T, xlim=c(0,1.3), col=col, border=NA, xaxt='n')
    graphics::title(main=title, cex.main=1.1)
    graphics::axis(1, at=seq(0,1,by=.2), labels=seq(0,1,by=.2))
    graphics::mtext(text=paste('N=',n,', NA=',NAs,sep=''), cex=.7)
    if(show.group.name) graphics::text(x=tableProp,y=ypos, labels=tableProp,cex=.9,pos=4)
}
.dpGLM_densities   <- function(data, qline=T, quantiles=c(.05,.995), ncat=T, title=NULL)
{
    ## check if there is any numerical variable for the summary
    maxVars <- 16
    if(ncol(data)>16)
        stop(cat("\n\n Max variables permited by default:",maxVars))

    op=graphics::par(no.readonly=TRUE)
    graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=.9, mar=c(3,3,3,1), mgp = c(2,.6,0))

    data <- data.frame(data)
    idxChar <- sapply(sapply(data, class), function(x) x[[1]]) == 'factor' |
        sapply(sapply(data, class), function(x) x[[1]]) == 'character'  |
        sapply(sapply(data, class), function(x) x[[1]]) == 'ordered'
    
    idxNum <- !idxChar
    idxFactor <- sapply(sapply(data, class), function(x) x[[1]]) == 'factor' |
        sapply(sapply(data, class), function(x) x[[1]]) == 'ordered'
    
    m <- ceiling(sqrt(ncol(data)))
    if(m*(m-1)>=ncol(data))
        graphics::par(mfrow=c(m-1,m))
    else
        graphics::par(mfrow=c(m,m))

    if (!is.null(title)){graphics::par(mar=c(3, 3, 5, 1))}
    if (sum(idxNum)>0){
        X <- as.data.frame(data[,idxNum])
        for (i in 1:ncol(X)){
            x <- X[,i]
            dpGLM_plotDensity(x,main=names(data[,idxNum])[i], qline)
            q <- stats::quantile(x,probs=quantiles)
            graphics::abline(v=q, col='red', lty=2)

        }
    }
    if (sum(idxFactor)>0 ){
        X <- as.data.frame(data[,idxFactor])
        for (i in 1:ncol(X)){
            x <- X[,i]
            .dpGLM_barPlot(as.factor(x), title=names(data[,idxFactor])[i])
        }
    }
    graphics::par(op)
}

dpGLM_select_non_zero <- function(x, select_perc_time_active=60)
{
    summary_post = summary(x)
    summary_post = data.frame(parameter=row.names(summary_post),summary_post, row.names=1:nrow(summary_post))  %>% tibble::as_data_frame()

    clusters_active = summary_post %>%
        dplyr::filter(parameter != "sigma") %>% 
        dplyr::select(parameter, Cluster, dplyr::contains("HPD"), Percentage.of.Iter..Cluster.was.active) %>% 
        dplyr::group_by(Cluster) %>% 
        dplyr::filter(!all(HPD.l <= 0 & 0 <= HPD.u), Percentage.of.Iter..Cluster.was.active>select_perc_time_active) %>%
        dplyr::ungroup() %>%
        dplyr::select(Cluster) %>%
        unique %>%
        dplyr::pull()

    n.iter = attr(x$samples, 'mcpar')[2]
    x$samples = coda::as.mcmc(x$samples[x$samples[,"k"] %in% clusters_active,])
    attr(x$samples, 'mcpar')[2] = n.iter

    return(x)
}



## }}}

## ------------------------------------
## hdpGLM
## ------------------------------------
#' @export
print.hdpGLM <- function(x, ...)
{
    cat(paste0("\nMaximum number of clusters activated during the estimation: ", x$max_active, sep=''))
    cat(paste0("\nNumer of MCMC iterations: ", x$n.iter, sep=''))
    cat(paste0("\nburn-in: ", x$burn.in, "\n", sep=''))
    cat("\nSummary statistics of cluster with data points\n")
    s = summary(x)
    print(s)
    invisible()
}
#' @export
summary.hdpGLM_data <- function(x)
{
    betas = x$parameters$beta %>% 
        base::data.frame(.) %>%
        dplyr::mutate(Parameter=rownames(.)) %>% 
        tidyr::gather(key=j, value=True, -Parameter) %>%
        dplyr::mutate(k = gsub(x=j, 'j.[0-9]*.k.', ''),
                      j = gsub(x=j, '.k.[0-9]*', ''),
                      j = gsub(x=j, 'j.', ''),
                      j = as.numeric(as.character(j)),
                      k = as.numeric(as.character(k))) %>%
        dplyr::select(j,k,Parameter, True) %>%
        dplyr::as_data_frame(.) 
    taus = x$parameters$tau %>%
        base::data.frame(dw = rownames(.), .) %>%
        tidyr::gather(key=dx, value=True, -dw) %>%
        dplyr::mutate_all(funs(as.numeric(gsub(., pattern='[a-z]', replacement=''))) ) %>%
        dplyr::mutate(Parameter = paste0('tau', dw,dx, sep='') )  %>%
        dplyr::select(dw,dx,Parameter, True) 
    return(list(data = summary(x$data),beta=betas, tau=taus))
}
## {{{ docs }}}
#' Summary of samples from hdpGLM
#'
#' This is a generic summary function that describes the output of the function \link{hdpGLM}
#'
#' @param x an object of the class \code{hdpGLM} generted by the function \link{hdpGLM}
#'
#' @param true.beta a \code{data.frame} with the true values of the linear coefficients \code{beta} if they are known. The \code{data.frame} must contain a column named \code{j} with the index of the context associated with that particular linear coefficient \code{beta}. It must match the indexes used in the data set for each context. Another column named \code{k} must be provided, indicating the cluster of \code{beta}, and a column named \code{Parameter} with the name of the linear coefficients (\code{beta1}, \code{beta2}, ..., \code{beta_dx}, where \code{dx} is the number of covariates at the individual level, and beta1 is the coefficient of the intercept term). It must contain a column named \code{True} with the true value of the \code{betas}. Finally, the \code{data.frame} must contain columns with the context-level covariates as used in the estimation of the \link{hdpGLM} function (see Details below).
#'
#' @param true.tau a \code{data.frame} with four columns. The first must be named \code{dw} and it indicates the index of each context-level covariate, starting with 1 for the intercept term. The second column named \code{dx} must contain the indexes of the individual level covariates, starting with 1 for the intercept term. The third column named \code{Parameter} must be named \code{tau<dw><dx>}, where \code{dw} and \code{dx} must be the actual values displayed in the columns \code{dw} and \code{dx}. Finally, it must have a column named \code{True} with the true value of the parameter.
#'
#' @return The function returns a list with two data.frames. The first summarizes the posterior distribution of the linear coefficients \code{beta}. The mean, median, and the 95% HPD interval are provided. The second data.frame contains the summary of the posterior distribution of the parameter \code{tau}.
#'
#' @details The function hdpGLM returns a list with the samples from the posterior distribution along with other elements. That list contains an element named \code{context.cov} that connects the indexed "C" created during the estimation and the context-level covariates. So each unique context-level covariate gets an index during the estimation. The algorithm only requires the context-level covariates, but it creates such index C to help the estimation. If true.beta is provided, it must contain indexes for the context as well, which indicates the context of each specific linear coefficient \code{beta}. Such index will probably be different from the one created by the algorithm. Therefore, when the \code{true.beta} is provided, we need to connect the context index C generated by the algorithm and the column j in the true.beta data.frame in order to compare the true values and the estimated value for each context. That is why we need the values of the context-level covariates as well. The summary uses them as key to merge the true and the estimated values for each context. The true and estimated clusters are matched based on the shortest distance between the estimated posterior average and the true value in each context because the labels of the clusters in the estimation can vary, even thought the same data points are classified in the same clusters.
#' @examples
#'
#' \dontrun{
#' }
#' @export
## }}}
summary.hdpGLM <- function(x, HPD.prob=.95, only.occupied.clusters.in.contexts=TRUE, true.beta=NULL, true.tau=NULL)
{
    if(only.occupied.clusters.in.contexts)   x = hdpGLM_get_occupied_clusters(x)
    if(!is.null(true.beta)){
        ## first we need to match the index of the contexts provided by the user and the one used by the algorithm (see details in the function help)
        c.covars.names = true.beta %>% dplyr::select(-j,-k, -Parameter, -True) %>% names
        true.beta      = true.beta  %>% dplyr::full_join(.,  x$context.cov, by=c.covars.names) %>% dplyr::rename(j.user.provided=j, j=C) 
        ## then for each context, we match the clusters based on smaller distance
        betas          = hdpGLM_match_clusters(x, true=true.beta)
    }else{
        HPD.lower <- function(x) {return(coda::HPDinterval( coda::as.mcmc(x) )[,"lower"])}
        HPD.upper <- function(x) {return(coda::HPDinterval( coda::as.mcmc(x) )[,"upper"])}
        betas = x$samples %>%
            dplyr::as_data_frame(.)  %>% 
            tidyr::gather(key=Parameter, value=sample, -k, -j) %>% 
            dplyr::group_by(k,j, Parameter) %>%
            dplyr::summarize_all(.funs=list(Mean="mean", Median="median", SD="sd", "HPD.lower", "HPD.upper")) %>%
            dplyr::ungroup(.)
    }
    taus = x$tau %>%
        summary(.) %>% 
        .[[1]] %>% 
        base::data.frame(Parameter=rownames(.), .) %>%
        dplyr::full_join(., x$tau %>% 
                            summary(.) %>% .[[2]] %>% 
                            base::data.frame(Parameter=rownames(.), .)  %>% 
                            dplyr::select(Parameter, X2.5., X97.5.), by="Parameter") %>% 
        dplyr::rename(HPD.lower=X2.5., HPD.upper=X97.5.) %>%
        dplyr::select(Parameter, Mean, SD, dplyr::contains("HPD"), -dplyr::contains("Naive"), -dplyr::contains("Time")) %>%
        tibble::as_data_frame(.) 
    if(!is.null(true.tau)){
        taus = taus %>%
            dplyr::mutate(Parameter=as.character(Parameter)) %>% 
            dplyr::full_join(., true.tau  %>% dplyr::mutate(Parameter=as.character(Parameter))  , by=c("Parameter"))  %>%
            dplyr::select(dw, dx, Parameter, True, Mean, SD, dplyr::contains("HPD"))
    }
    return(list(beta=betas, tau=taus))
}
#' @export
plot.hdpGLM <- function(x, true.beta=NULL, ncol=NULL,  legend.position="bottom", ...)
{
    x = hdpGLM_get_occupied_clusters(x)
    if (!is.null(true.beta)) {
        ## first we need to match the index of the contexts provided by the user and the one used by the algorithm (see details in the function help)
        c.covars.names = true.beta %>% dplyr::select(-j,-k, -Parameter, -True) %>% names
        true.beta      = true.beta  %>% dplyr::full_join(.,  x$context.cov, by=c.covars.names) %>% dplyr::rename(j.user.provided=j, j=C) 
        ## then for each context, we match the clusters based on smaller distance and prepare the table for plotting
        tab =  hdpGLM_match_clusters(x, true=true.beta) %>%
            dplyr::mutate(jnext = j+1) %>%
            dplyr::mutate(Parameter = paste0(stringr::str_extract(Parameter, 'beta') , '[', stringr::str_extract(Parameter, '[0-9]+') ,']'))
        xlim = tab %>%
            dplyr::summarize(lower=min(HPD.lower),
                             upper=max(HPD.upper)) %>%
            c %>%
            unlist
        g = x$samples %>%
            tibble::as_data_frame(.)  %>%
            dplyr::select(-sigma)  %>% 
            tidyr::gather(key = Parameter, value=values, -j, -k) %>%
            dplyr::mutate(Parameter = paste0(stringr::str_extract(Parameter, 'beta') , '[', stringr::str_extract(Parameter, '[0-9]+') ,']')) %>%
            ggplot2::ggplot(.) +
            ggjoy::geom_joy(aes(x=values, y=j, group=j), fill="#00000044") +
            ggplot2::geom_segment(data=tab , aes(x=True, xend=True, y=j, yend=jnext, col='red')) +
            ## ggplot2::geom_segment(data=tab , aes(x=Mean, xend=Mean, y=j, yend=jnext, col='black')) +
            ggplot2::facet_wrap( ~ Parameter, ncol = ncol, scales='free', labeller=label_parsed) +
            ggplot2::ylab('Context Index') +
            theme_bw()+
            ggplot2::theme(strip.background = element_rect(colour="white", fill="white"),
                           strip.text.x = element_text(size=12, face='bold'),
                           strip.text.y = element_text(size=12, face="bold")) +
            ggplot2::scale_colour_manual(values = c("red", "black"), name="", labels=c('True', "MCMC Cluster Mean")) +
            ggplot2::theme(legend.position = legend.position) +
            xlim(xlim)
    }else{
        xlim = summary(x)$beta %>%
            dplyr::summarize(lower=min(HPD.lower), upper=max(HPD.upper)) %>% c %>% unlist
        g = x$samples %>%
            tibble::as_data_frame(.)  %>%
            dplyr::select(-sigma)  %>% 
            tidyr::gather(key = Parameter, value=values, -j, -k) %>%
            dplyr::mutate(Parameter = paste0(stringr::str_extract(Parameter, 'beta') , '[', stringr::str_extract(Parameter, '[0-9]+') ,']')) %>%
            ggplot2::ggplot(.) +
            ggjoy::geom_joy(aes(x=values, y=j, group=j), fill="#00000044") +
            ggplot2::ylab('Context Index') +
            ggplot2::facet_wrap( ~ Parameter, ncol = ncol, scales='free', labeller=label_parsed) +
            theme_bw()+
            ggplot2::theme(strip.background = element_rect(colour="white", fill="white"),
                           strip.text.x = element_text(size=12, face='bold'),
                           strip.text.y = element_text(size=12, face="bold")) +
            xlim(xlim)

    }
    return(g)
}
#' @export
hdpGLM_get_occupied_clusters <- function(x)
{
    active = apply(x$pik, 1, which.max)
    active_in_each_context = tibble::data_frame(k=active, j = x$context.index) %>%
        dplyr::filter(!base::duplicated(.)) %>%
        dplyr::mutate(flag = 'select')
    x$samples = x$samples %>%
        tibble::as_data_frame(.) %>%  
        dplyr::full_join(., active_in_each_context, by=c('k', 'j')) %>%
        dplyr::filter(flag=='select') %>%
        dplyr::select(-flag) %>%
        as.matrix %>% 
        coda::as.mcmc(.)
    n.iter = attr(x$samples, 'mcpar')[2]
    attr(x$samples, 'mcpar')[2] = n.iter
    return(x)
}

## ---------------------
## Both dpGLM and hdpGLm
## ---------------------
## {{{ docs }}}
#' Match Labels of Estimation and True Clusters
#'
#' This function matches the estimated clusters and the true values of the linear coefficients of the clusters.
#'
#' @param samples a \code{\link{dpGLM}} object, output of the function \code{\link{hdpGLM}}
#' @param true a list with the true values of the parameters that generate the data (See \code{\link{hdpGLM_simulateParameters}})
#'
#' @return The function returns a table with the labels of the clusters from the MCMC estimation provided by the function \code{\link{hdpGLM}} and the labels used to generate the data, which is in the column \code{True.Cluster.match} of the output. The output table also contains the true value of the linear coefficients that were used to generate the data.
#'
#' @export
## }}}
hdpGLM_match_clusters <- function(samples, true)
{
    if(class(samples) == 'dpGLM'){
        tab = summary(samples) %>%
            data.frame(Parameter=row.names(.), ., row.names=1:nrow(.)) %>%
            dplyr::filter(Parameter!="sigma") %>% 
            dplyr::select(Parameter, Cluster, Mean) %>% 
            dplyr::group_by(Cluster) %>%
            dplyr::mutate(True.Cluster.match = purrr::pmap_int(list(list(Mean)), true$beta, .f=function(mean, beta) which.min(unlist(lapply(beta, function(v) edist(mean,v)))) )) %>%
            dplyr::mutate(Parameter=as.character(Parameter)) %>%
            dplyr::ungroup() %>%
            dplyr::select(-Mean)

        tab = do.call(rbind,true$beta) %>%
            cbind(True.Cluster.match=1:nrow(.)) %>% 
            tibble::as_data_frame() %>%
            dplyr::mutate(True.Cluster.match=as.integer(True.Cluster.match)) %>% 
            tidyr::gather(key='Parameter', value='True', 1:(ncol(.)-1)) %>%
            dplyr::right_join(.,tab, by=c("Parameter","True.Cluster.match")) %>%
            dplyr::select(Cluster, True.Cluster.match, Parameter, True) %>% 
            dplyr::arrange(True.Cluster.match)
    }
    if(class(samples) == 'hdpGLM'){
        estimates = summary(samples)$beta 
        tab       = tibble::data_frame() 
        for (j in unique(estimates$j))
        {
            truej = true[true$j==j,]
            tabj  = estimates[estimates$j==j,]
            tabj = tabj %>%
                dplyr::filter(Parameter!="sigma")  %>%
                dplyr::group_by(k) %>%
                dplyr::mutate(True.Cluster.match = purrr::pmap_dbl(.l = list(estimate = list(tibble::data_frame(Parameter=Parameter, Mean=Mean)),
                                                                             true     = list(truej) ),
                                                                   .f=function(estimate, true) hdpGLM_match_clusters_aux(estimate, true) ),
                              Parameter=as.character(Parameter)) %>%
                dplyr::ungroup(.) %>%
                dplyr::left_join(., truej , by=c("True.Cluster.match"= "k", 'Parameter', "j"))
            tab = tab %>%
                dplyr::bind_rows(., tabj)  
        }
        tab = tab %>%
            dplyr::select(j, k, True.Cluster.match, Parameter, True, dplyr::everything())  %>% 
            dplyr::arrange(j, k, Parameter)
    }
    return(tab)
}


