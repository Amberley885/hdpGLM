

## dpGLM
## -----
## {{{ Sample from Posterior }}}

## {{{ docs }}}

#' Defaul plot for class dpGLM
#'
#' This function generate desity plots with the posterior distribution generated by the function \code{\link{hdpGLM}}
#'
#' @param x a dpGLM object with the samples from generated by
#'                \code{\link{hdpGLM}}
#' @param K integer, the number of estimated clusters to plot
#' @param separate boolean, if \code{TRUE} the coefficients of the \code{K} first clusters will be displayed in a separate panel in the plot. If \code{FALSE}, only the beta coefficient will be displayed in a separate panel in the plot
#' @param hpd boolean, if \code{TRUE} the and \code{separate=T}, the .95 HPD lines will be displayed.
#' @param true_parameters either \code{NULL} or a list with the true parameter values if they are known. The list must be as prescribed for the parameter \code{parameters} of the function \code{\link{hdpGLM_simulateData}}
#' @param plot.hist boolean, if \code{TRUE} it generates a histogram with the frequency the cluster \code{k} was active (i.e., there was data points classified as belonging to that cluster) during the estimation
#' @param plot.hist.k boolean, if \code{TRUE} it generates a plot with the histogram of the estimated cluster indicator
#' @param layout either \code{NULL} or a two-dimensional vector with integers indicating the number of rows and coluns to plot. If \code{NULL}, the grid is provided
#' @param title  string, the title of the plot
#' @param prop.time.active a number between 0 and 1. When \code{separate=F} and \code{plot.hist=T}, it will count the number of cluster that was active in the provided proportion of the time
#' @inheritParams graphics::par
#' 
#' @return 
#'
#' @examples
#' dt    = hdpGLM_simulateData(n=5000,nCov=4, K=5, family='gaussian')
#' mcmc    = list(burn.in = 0,  n.iter = 2000)
#' samples = hdpGLM(y~., data=dt$data, mcmc=mcmc,
#'                  family='gaussian', n.display=30, K=100)
#'
#' plot(samples, K=5, true_parameters=data$parameters)
#' 
#' \dontrun{
#' }
#' @export

## }}}
plot.dpGLM <- function(x, K=1, separate=F, hpd=T, true_parameters=NULL, plot.hist=T, plot.hist.k=T, layout=NULL, title=NULL, prop.time.active=.95, ...)
{
    
    par.default <- graphics::par(no.readonly = TRUE)
    on.exit(graphics::par(par.default), add=TRUE)
    op.default <- options()
    on.exit(options(op.default), add=TRUE)
    dir.default <- getwd()
    on.exit(setwd(dir.default), add=TRUE)


    sample = as.data.frame(x$samples)
    n.mcmc = attr(x$samples,'mcpar')[2]

    ## plotting betas
    ## --------------
    graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=1.2, mar=c(3,3,2,1), mgp = c(2,.6,0))
    Z     = sample %>% dplyr::select(k)  %>% c %>% unlist 
    high.freq.cluster = table(Z) %>% sort  %>% rev  %>% names  %>% as.numeric %>% .[1:K]
    betas = sample %>% dplyr::select(dplyr::contains('beta'))

    if(!is.null(title)) graphics::par(mar=c(2, 3, 5, 2)) 
    if (separate)
    {
        if(is.null(layout)) graphics::par(mfrow=c(K,ncol(betas)))

        for (k in high.freq.cluster )
        {
            beta = betas[Z==k,]
            for (d in 1:ncol(beta))
            {
                betad = beta[,d]
                hpd999 = coda::HPDinterval(coda::as.mcmc(betad), prob=.99)
                hpd95  = coda::HPDinterval(coda::as.mcmc(betad), prob=.95)
                betad = betad[hpd999[1] <= betad & betad <= hpd999[2] ]
                if(plot.hist){col="lightsteelblue1"}else{col="white"}
                graphics::hist(betad, col=col, border='white', breaks=30, main=bquote(beta[.(k)~.(d)]), probability=T, xlab='',xlim=hpd999)
                graphics::lines(stats::density(betad, adjust=.8), col='grey')
                if (!is.null(true_parameters))
                {
                    graphics::abline(v=unlist(lapply(true_parameters$beta,'[',d)), col='black', lty=2)
                    graphics::legend('topright', legend=bquote('True'~beta[~'k=1:'~.(K)~","~.(d)]),lty=2, bty='n', cex=.8)
                }
                if(hpd)
                {
                    graphics::abline(v=hpd95, col='red', lty=3)
                    graphics::legend('bottomright', legend='95% HPD', bty='n', lty=3, col='red')
                }
            }
        }
        if (plot.hist.k)
        {
            grDevices::dev.new()
            graphics::hist(x$samples[,'k'], col="lightsteelblue1", border='white')
            graphics::abline(v=true_parameters$k)
        }
    }else
    {
        if(is.null(layout)) layout = .get_layout(ncol(betas)+1)
        graphics::par(mfrow=layout)

        ## Bar plot with number of clusters
        if(plot.hist.k){
            k.distr = table(x$samples[,'k'])/n.mcmc
            graphics::barplot(sort(k.distr, decreasing=T), horiz=T, xlab='Proportion of the time Active in the Estimation',
                              ylab='Cluster Label', col="lightsteelblue1", border='white')
            t1=paste0("Maximum Number of clusters activated: ", length(k.distr),  sep='')
            t2=paste0("Number of clusters ",round(100*prop.time.active,0),"% of the time active: ", sum(k.distr>=prop.time.active),  sep='')
            graphics::legend('topright', legend=c(t1,t2), bty='n')
            ## hist(n.clusters, col="lightsteelblue1", border='white')
            ## graphics::abline(v=true_parameters$k)
        }

        cols=ifelse(K>1, grDevices::palette(grDevices::rainbow(K)), 'black')
        beta = betas[Z %in% high.freq.cluster,]
        for (d in 1:ncol(beta))
        {
            betad = beta[,d]
            hpd999 = coda::HPDinterval(coda::as.mcmc(betad), prob=.999)
            betad = betad[hpd999[1] <= betad & betad <= hpd999[2] ]

            if(plot.hist){col="lightsteelblue1"}else{col="white"}
            graphics::hist(betad, col=col, border='white', breaks=70, main=bquote(beta[.(d)]), probability=T, xlab='')
            graphics::lines(stats::density(betad, adjust=.2))
            true = sapply(true_parameters$beta, function(x) x[d])
            graphics::abline(v=true, col=cols, lty=1:K)
            graphics::legend('topright', legend=paste0('True in Cluster ',1:K, sep=''), col=cols, lty=1:K, bty='n', cex=.9)
        }
    }
    if (!is.null(title)){graphics::title(title,  outer=T, line=-1.5, cex=.8)}
    
}
summary.dpGLM <- function(x, nK = 'all', HPD.prob=.95, burn.in=NULL, ...)
{
    if ( ! (is.numeric(nK) | nK == 'all') ){stop('nK must be either \'all\' of an integer')}

    if (nK=='all'){K = unique(x$samples[,'k'])
    }else{         K = as.numeric(names(sort(table(x$samples[,'k']), decreasing=T))[1:floor(nK)])}

    if (!is.null(burn.in))
    {
        x$samples = coda::as.mcmc(x$samples[burn.in:nrow(x$samples),])
        attr(x$samples, 'mcpar')[2]  = attr(x$samples, 'mcpar')[2] - burn.in
    }
    
    n.mcmc.sample = attr(x$samples, 'mcpar')[2]
    summ = matrix(nrow=0 , ncol=8)

    stopifnot(inherits(x, "dpGLM"))
    for (k in K){
        idx.cluster = x$samples[,'k'] == k
        xk = coda::as.mcmc(x$samples[ idx.cluster, ])
        xk = x$samples[ idx.cluster, -1]
        if (is.null(nrow(xk))){
            ## it is done b/c if there is 1 row, xk is treated as vector by R, and summary and coda::HPDinterval is incorrectly computed
            xk=rbind(xk,xk)
            n.active = round(100*1/n.mcmc.sample,1)
            xk=coda::as.mcmc(xk)
        }else{
            n.active = round(100*nrow(xk)/n.mcmc.sample,1)
            xk=coda::as.mcmc(xk)
        }
        summ = rbind(summ, cbind(k, summary(xk)[[1]], coda::HPDinterval(xk, HPD.prob), n.active))
    }
    summ = summ[order(summ[,'n.active'], decreasing=T),]
    summ           = summ[,c('k',       'Mean','lower','upper','SD','Naive SE', 'Time-series SE', 'n.active')]
    colnames(summ) =         c('Cluster', 'Mean','HPD.l','HPD.u','SD','Naive SE', 'Time-series SE', 'Percentage of Iter. Cluster was active')
    return(summ)
}

## }}}
## {{{ data }}}

plot.dpGLM_data <- function(sim_data, title, ...)
{
    if(all(sim_data$data$y==0 | sim_data$data$y==1)) sim_data$data$y = as.factor(sim_data$data$y)
    .dpGLM_densities(sim_data$data)
    graphics::title(title, outer=T, line=-1, cex.main=.9)
}
dpGLM_plotDensity  <- function(x, ub=stats::quantile(x,.975), lb=stats::quantile(x,.025), shaded.area=F, shaded.area.col='grey90', lty=1, bty='n', add=F, grid=T, ...)
{
    data.rug = sample(x, size=min(1000, length(x)))
    if (add) {
        graphics::lines(stats::density(x, adjust=1), lty=lty,  cex.axis=.9, ...)
    }else{
        graphics::plot(stats::density(x, adjust=1), lty=lty,  cex.axis=.9, ...)
    }
    graphics::rug(x=data.rug)
    if(shaded.area){
    ## shadded area
        ## x.new <- density(x, adjust=1)$x
        x.new<- stats::density(x, adjust=1)$x
        y <- stats::density(x, adjust=1)$y
        x.coord <- c(lb, x.new[lb <= x.new & x.new <= ub], ub)
        y.coord <- c(0,  y[lb <= x.new & x.new <= ub], 0)
        graphics::polygon(x.coord,y.coord,col=shaded.area.col, lty=lty, border= NA)
        length(x.coord)
        length(y.coord)
    }
    if(grid) grid()
}
.dpGLM_barPlot       <- function(y, title='', show.group.name=T, show.group.count=T, col='lightgrey')
{
    if(class(y)=='table') {
        n <- sum(table)
        NAs <- 0
        table <- y
        tableProp <- round(y/sum(y),3)
    }else{
        y <- factor(y)
        n <- length(y)
        NAs <- sum(is.na(y))
        table <- table(y)
        tableProp <- round(table(y)/length(y),3)
        
    }
    if (show.group.count){
        N <- paste('\n(N=',table,')', sep='')
        names(tableProp) <-  paste(names(table),N)
    }        
    ypos <- graphics::barplot(tableProp, horiz=T, xlim=c(0,1.1), main=title,plot=F)
    graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=.9, mar=c(4,5,3,0))
    graphics::barplot(tableProp, horiz=T, xlim=c(0,1.3), col=col, border=NA, xaxt='n')
    graphics::title(main=title, cex.main=1.1)
    graphics::axis(1, at=seq(0,1,by=.2), labels=seq(0,1,by=.2))
    graphics::mtext(text=paste('N=',n,', NA=',NAs,sep=''), cex=.7)
    if(show.group.name) graphics::text(x=tableProp,y=ypos, labels=tableProp,cex=.9,pos=4)
}
.dpGLM_densities <- function(data, qline=T, quantiles=c(.05,.995), ncat=T, title=NULL)
{
    ## check if there is any numerical variable for the summary
    maxVars <- 16
    if(ncol(data)>16)
        stop(cat("\n\n Max variables permited by default:",maxVars))

    op=graphics::par(no.readonly=TRUE)
    graphics::par(las=1,cex.axis=.7,bty='l', pch=20, cex.main=.9, mar=c(3,3,3,1), mgp = c(2,.6,0))

    data <- data.frame(data)
    idxChar <- sapply(sapply(data, class), function(x) x[[1]]) == 'factor' |
        sapply(sapply(data, class), function(x) x[[1]]) == 'character'  |
        sapply(sapply(data, class), function(x) x[[1]]) == 'ordered'
    
    idxNum <- !idxChar
    idxFactor <- sapply(sapply(data, class), function(x) x[[1]]) == 'factor' |
        sapply(sapply(data, class), function(x) x[[1]]) == 'ordered'
    
    m <- ceiling(sqrt(ncol(data)))
    if(m*(m-1)>=ncol(data))
        graphics::par(mfrow=c(m-1,m))
    else
        graphics::par(mfrow=c(m,m))

    if (!is.null(title)){graphics::par(mar=c(3, 3, 5, 1))}
    if (sum(idxNum)>0){
        X <- as.data.frame(data[,idxNum])
        for (i in 1:ncol(X)){
            x <- X[,i]
            dpGLM_plotDensity(x,main=names(data[,idxNum])[i], qline)
            q <- stats::quantile(x,probs=quantiles)
            graphics::abline(v=q, col='red', lty=2)

        }
    }
    if (sum(idxFactor)>0 ){
        X <- as.data.frame(data[,idxFactor])
        for (i in 1:ncol(X)){
            x <- X[,i]
            .dpGLM_barPlot(as.factor(x), title=names(data[,idxFactor])[i])
        }
    }
    graphics::par(op)
}

## }}}


## hdpGLM
## ------
