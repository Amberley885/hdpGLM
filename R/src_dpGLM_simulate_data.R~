


## {{{ docs }}}

#' Simulated a Data Set from hdpGLM model
#'
#' This function generates a data set from the Hierarchical
#' Dirichlet Process of Generalized Linear Model (hdpGLM)
#'
#'
#' @param n integer, the sample size of the data
#' @param K integer, the number of clusters
#' @param nCov integer, the number of covariates of the
#'             GLM components
#' @param nCovj either NULL or an integer indicating the number of
#'              covariates determining the average parameter of the
#'              base measure of the Dirichlet process prior
#' @param parameters either NULL or a list with the parameters
#'                   to generate the model. If not NULL, it must
#'                   contain a sublist name beta, a vector named tau,
#'                   and a vector named pi. The sublist beta must be
#'                   a list of vectors, each one with size nCov+1
#'                   to be the coefficients of the GLM mixtures
#'                   components that will generate the data.
#'                   The vector tau must be present only if nCovj
#'                   is not NULL, in which case it must be a vector
#'                   of size nCov+1 with the linear coefficients of
#'                   the average of the base measure. The vector pi
#'                   must add up to 1 and have length K.
#' @param pi either NULL or a vector with length K that add up to 1.
#'           If not NULL, it determines the mixture probabilities
#' @param seed a seed for \code{\link{set.seed}}
#' @inheritParams hdpGLM 
#'
#' @return The function returns a list with the data set, the parameters,
#'         the vector Z indicating the cluster of each observation, and
#'         the number of clusters.
#'
#' @examples
#' data = hdpGLM_simulateData(n=2000, K=2, nCov=0, family='gaussian')
#' \dontrun{
#' }
#' @export

## }}}
hdpGLM_simulateData <- function(n, K, nCov, nCovj=NULL, parameters=NULL, pi=NULL, family, seed=sample(1:777,1))
{
    ## error handling
    if (n %% 2) stop("Sample size n must be an even number")
    if(! family %in% c('gaussian', 'binomial', 'multivariate')) stop(paste0('Error: family must be one element of the set : {', paste0(c('gaussian', 'binomial', 'multinomial'), collapse=','),'}'))
    if (!is.null(parameters)){
        ## check the format of parameters
        if(! all(names(parameters) %in% c('pi', 'beta') | names(parameters) %in% c('pi', 'beta', 'K')) | is.null(names(parameters)) ) stop('\n\n\"parameters\" must be a named list. The names must be \'beta\' and \'pi\'.\n ')
        if(! length(parameters$beta) == K) stop(paste0('\n\nThe element \'beta\' of the list \'parameters\' must be a list itself with size ', K, '. Each element of that list must be a vector of ', nCov+1, ' linear parameter(s).' ,  sep=''))
        if(! length(parameters$pi) == K) stop(paste0('\n\nThe element \'pi\' of the list \'parameters\' must be a vector with size ', K,'.' ,  sep=''))
        if(! sum(parameters$pi) == 1) stop ('\n\nThe element \'pi\' of the list \'parameters\' must add up to 1.')
        if(! all(parameters$beta %>% purrr::map(., ~length(.)) %>% unlist == nCov +1)) stop(paste0('\n\nAll elements of the list \'beta\' of the list \'parameters\' must have length ', nCov+1, sep=''))
    }

    if (is.null(parameters)) {
        parameters <- hdpGLM_simulateParameters(K=K, nCov=nCov, pi, seed=seed) 
    }
    if(family=='gaussian'){sim_data = .hdpGLM_simulateData_gaussian(n=n, K=K, nCov=nCov, parameters, seed=seed)}
    if(family=='binomial'){sim_data = .hdpGLM_simulateData_binomial(n=n, K=K, nCov=nCov, parameters, seed=seed)}

    class(sim_data) = "dpGLM_data"
    return(sim_data)
}

## {{{ docs }}}

#' Simulated a Parameters used to create Data Sets from hdpGLM model
#'
#' This function generates parameters that can be used to
#' simulated data sets from the Hierarchical
#' Dirichlet Process of Generalized Linear Model (hdpGLM)
#'
#' @inheritParams hdpGLM_simulateData
#'
#' @return The function returns a list with the parameters
#'         used to generate data sets from the hdpGLM model.
#'         This list can be used in the function \code{\link{hdpGLM_simulateData}}
#' @examples
#' parameters = hdpGLM_simulateParameters(nCov=2) 
#'
#' \dontrun{
#' }
#' @export
## }}}
hdpGLM_simulateParameters <- function(nCov, nCovj=NULL, K, pi=NULL, seed=NULL)
{
    if(is.null(seed)) seed <- sample(1:777,1)
    parameters <- list(pi=NA ,beta = list(), K=K)

    ## pi
    ## --
    if(is.null(pi)){
        parameters$pi <- rep(1/K,K)
    }else{
        if(length(pi) != K) stop('\n\n Size of pi must be equal to K\n')
        parameters$pi <- pi
    }

    ## beta
    ## ----
    parameters$beta <- lapply(rep(nCov, K), function(nCov) stats::runif(n=nCov+1, -10,10))
    parameters$beta <- parameters$beta %>% purrr::map(., ~setNames(., paste0('beta', 1:(nCov+1), sep='')))

    return(parameters)
}


.hdpGLM_simulateData_gaussian <- function(n, K, nCov, parameters, seed)
{
    set.seed(seed)
    n = floor(n*parameters$pi)

    beta  = parameters$beta
    X     = list()
    y     = list()
    for (k in 1:K){
        epsilon   <- stats::rnorm(n=n[k], 0, 1)

        if(nCov!=0){
            X[[k]] <- MASS::mvrnorm(n=n[k], mu = rep(0,nCov), Sigma = diag(nCov))
            y[[k]] <- cbind(1,X[[k]]) %*% beta[[k]] + epsilon
        }else{
            X[[k]] <- NULL
            y[[k]] <- beta[[k]] + epsilon
        }
    }
    if(nCov!=0){
        data   = setNames(data.frame(y = unlist(y), X = data.frame(do.call(rbind, X))), nm=c('y', paste0('X',1:nCov)))
    }else{
        data   = data.frame(y = unlist(y))
    }
    return ( list(data=data, Z = rep(1:K,n), parameters=parameters) )
}
.hdpGLM_simulateData_binomial <- function(n, K, nCov, parameters,  seed)
{
    set.seed(seed)
    n = floor(n*parameters$pi)

    beta  = parameters$beta
    X     = list()
    y     = list()
    p     = list()
    nu    = list()
    for (k in 1:K){
        epsilon  <- stats::rnorm(n=n[k], 0, 1)

        if(nCov!=0){
            X[[k]]   <- stats::mvrnorm(n=n[k], mu = rep(0,nCov), Sigma = diag(nCov))
            nu[[k]]  <- cbind(1,X[[k]]) %*% beta[[k]]
            p[[k]]   <- 1/(1+exp(-nu[[k]]))
        }else{
            X[[k]]   <- NULL
            nu[[k]]  <- rep(beta[[k]], n[k]) 
            p[[k]]   <- 1/(1+exp(-nu[[k]]))
        }
        y[[k]] = rep(NA, n[k])
        for (i in 1:n[k]) y[[k]][i] = rbinom(n=1, size=1, prob=p[[k]][i])
    }
    if(nCov!=0){
        data   = setNames(data.frame(y = unlist(y), X = data.frame(do.call(rbind, X))), nm=c('y', paste0('X',1:nCov)))
    }else{
        data   = data.frame(y = unlist(y))
    }
    return ( list(data=data, Z = rep(1:K,n), parameters=parameters) )
}
## to be completed
.hdpGLM_simulateData_multinomial <- function(n, K=2, nCov=0, pi=pi,  family, seed){
    
    set.seed(seed)
    ## rand('state', state);
    ## randn('state', state);

    # n is the total sample size (must be an even number)
    ## J = J = nClass = 4; # dep var  : number of categories of y: y in {1,2,3,4}
    ## D = l = nVar = 5;   # covars   : dimension of X (does not include the intercept !)
    ## K = 2               # clusters : pre fixed number of components (clusters)
    ## pi = rep(1/K,K)
    ## n = 2*5000
    n = n*pi

    alpha = list()
    beta  = list()
    tau   = list() 
    nu    = list() 
    mu    = list()
    sd    = list()
    X     = list()
    y     = list()
    eta   = list()
    p     = list()
    for (k in 1:K){
        ## hyperpriors on G_o (for tau and nu)
        tau[[k]]  <-  sqrt( exp( stats::rnorm(n=1, mean=0, sd=.1)) );    ## ln(tau^2) ~ N(0,.1^2)
        nu[[k]]   <-  sqrt( exp( stats::rnorm(n=1, mean=0, sd= 2)) );     ## ln(nu^2)  ~ N(0,2^2)

        ## Priors for theta defined by G_o
        mu[[k]]     <- stats::rnorm(n=D, mean=0, sd=1);                    ## mu          ~ N_d(0,1)   which is expect of X ~ N_d(mu, sigma^2 * I)
        sd[[k]]     <- sqrt( exp( stats::rnorm(n=D, mean=0, sd=2) ) );  ## ln(sigma^2) ~ N_d(0,2^2) which is var    or X ~ N_d(mu, sigma^2 * I)
        alpha[[k]]  <- stats::rnorm(n=J,mean=0, sd=tau[[k]] )
        beta[[k]]   <- stats::mvrnorm(n=D,mu=rep(0,J), Sigma=nu[[k]]^2  * diag(J))

        ## generating X's
        ## --------------
        X[[k]]  <-  stats::mvrnorm(n=n[k], mu = mu[[k]], Sigma = sd[[k]] * diag(D))

        ## computing y, eta = alpha + X^T beta, and p = exp(eta)/sum(exp(eta))
        ## -------------------------------------------------------------------
        eta[[k]]   <-  cbind(1, X[[k]]) %*% rbind(alpha[[k]], beta[[k]])
        eta[[k]]   <-  eta[[k]] + stats::mvrnorm(n[k], mu=rep(0,J), Sigma = .05 * diag(J))
        p[[k]]     <-  t(apply(eta[[k]], 1, function(eta.kj) exp(eta.kj) / sum(exp(eta.kj)) ))
        y[[k]] <- rep(NA, n[k])
        for (i in 1:n[k]) y[[k]][i]  = which(rmultinom(n=1, size=1, prob=p[[k]][i,]) == 1)

    }
    return ( list(y = unlist(y),
                  X = setNames(data.frame(do.call(rbind, X)), nm=paste0('X',1:D) ),
                  Z = rep(1:K,n)) )
}


